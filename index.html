<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>EMOJI BATTLE</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<script src='js/GLTFLoader.js'></script>
	<!-- include jsartookit -->
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>

	<link href="https://fonts.googleapis.com/css?family=Barlow+Condensed|Bungee" rel="stylesheet">

	<style>

	.fullscreen {
		position: absolute;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
	}

	.titlefont {
		font-family: 'Bungee', cursive;
		color: white;
		font-size: 6vh;
	}

	
	.setupQuestion {
		font-family: 'Bungee', cursive;
		color: white;
		font-size: 3vh;
	}

	.setupInstructions {
		font-family: 'Barlow Condensed', cursive;
			color: white;
			font-size: 3vh;
	}

	.centerItems {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		text-align: center;
	}

	#titlescreen {
		z-index: 100;
	}

	#titlescreen img {
		height: 50vh;
		width: 50vh;
	}

	#setupscreen {
		z-index: 1000;
	}

	#setupscreen img {
		height: 15vh;
		width: 15vh;
		align-self:center;
		justify-content: flex-start;
		position: absolute;
		top:0;
	}

	.rectangle {    
		background: radial-gradient(circle, #00CFFF 0%, #00FFDF 100%);
	}

	.show {
		opacity: 1;
		transition: opacity 1s;
	}
	.hide {
		opacity: 0;
		transition: opacity 1s;
		pointer-events: none;
	}

	.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
}

#UI{
	justify-content: flex-end;
}

.button img {
	position: relative;
	width: 100%;
	height: 100%;
}
.button {
	border-radius: 100%;
	height: 10vh;    
	width: 10vh;     
	border: 1px solid #F7DD00;    
	background-color: rgba(216,216,216,0.5);
	margin-bottom: 10vh;
}
.button:active {
	border: 1px solid #FF00B4;    
	background-color: rgba(216,216,216,0.5);
}

	</style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;' class="noselect">

<div id="setupscreen" class="show rectangle fullscreen centerItems">
	<img src="images/EmojiFightLogo.png" />
	<p class="setupInstructions">To experience in AR, <br/>
			Emoji Fight needs your camera</p>
	<div class="setupQuestion">Can We Use It?</div>
</div>

<div id="titlescreen" class="hide rectangle fullscreen titlefont centerItems">
		<img src="images/EmojiFightLogo.png" />
		<div>START</div>
	</div>

	<div id="UI" class="fullscreen centerItems">
<a class="button"><img id="FireButton" src="textures/fire.png" /></a>
</div>
<script>

var scene, camera, renderer, clock, deltaTime, totalTime, raycastCamera;
var intersectables =[];
var arToolkitSource, arToolkitContext;

var markerRoot1;

var mesh1;

var box = new THREE.BoxGeometry(0.2, 0.2, 0.2);
var boxMat = new THREE.MeshBasicMaterial();
var boxMesh = new THREE.Mesh(box, boxMat);

var boxes = [];
//var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2(-10000,-10000);
var touch = false;

let firebutton = document.getElementById("FireButton");
let setupPage = document.getElementById("setupscreen");
let titlescreen = document.getElementById("titlescreen");

setupPage.addEventListener("touchstart", ()=>{
	initialize();
	setupPage.classList.remove('show');
	setupPage.classList.add("hide");
	titlescreen.classList.remove("hide");
	titlescreen.classList.add("show");
})


titlescreen.addEventListener("touchstart", ()=>{
	titlescreen.classList.remove('show');
	titlescreen.classList.add("hide");
	animate();
})

window.addEventListener("touchstart", (e)=>{
	// mouse.x = e.touches[0].clientX / window.innerWidth;
	// mouse.y = e.touches[0].clientY / window.innerHeight;
	touch = true;
})
window.addEventListener("touchend", (e)=>{
	touch = false;
	// mouse.x = -10000;
	// mouse.y = -10000;
})

let emojiTextureExtension = "png";
	let emojiList = [
		"burger",
		"fire",
		"key",
		"lion",
		"lock",
		"poo",
		"soccer",
		"toilet",
		"trophy",
		"water",
	];

let emojiMeshes = [];
let currentLevel = 0;
let currentEnemy = null;
let levels = [
		{
			ENEMY: 3, // Lion
			WEAPN: 0,
			HEALTH: 10,
			RATE: 0.5
		},{
			ENEMY: 4, // Lock
			WEAPN: 2,
			HEALTH: 15
		},{
			ENEMY: 1, // Fire
			WEAPN: 9,
		},{
			ENEMY: 7, // Toilet
			WEAPN: 5,
		},{
			ENEMY: 8, // Toilet
			WEAPN: 6,
		},
	]

function initialize()
{
	scene = new THREE.Scene();

	let ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 );
	scene.add( ambientLight );
				
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
	});

	function onResize()
	{
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		onResize()
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono'
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	markerRoot1 = new THREE.Group();
	scene.add(markerRoot1);
	let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
		type: 'pattern', patternUrl: "data/emojifight-bw.patt",
	})

	loadEmojis();

	setLevel(0);

	setInterval(()=>{
		setLevel(currentLevel + 1);
	},5000)

}

function loadEmojis () {
	let loader = new THREE.TextureLoader();
	let textures = {};

	emojiList.map(t=>{
		textures[t] = loader.load(`textures/${t}.${emojiTextureExtension}`);
	})

	let emojiGeometry = new THREE.PlaneBufferGeometry(1,1, 4,4);
	let emojiMaterial = new THREE.MeshBasicMaterial({
		side: THREE.DoubleSide,
	});
	let emojiMesh = new THREE.Mesh(emojiGeometry, emojiMaterial);

	Object.keys(textures).map((k,i)=>{
		const newEmoji = emojiMesh.clone();
			newEmoji.geometry = emojiMesh.geometry.clone();
			newEmoji.material = emojiMaterial.clone();
			newEmoji.material.map = textures[k];
			newEmoji.material.alphaTest = 0.5;
			newEmoji.material.needsUpdate = true;
			newEmoji.name = k;
			emojiMeshes.push(newEmoji);
	})
}

function setLevel(level) {
	if(levels[currentLevel]) {
		currentLevel = level;
		setButton(currentLevel);
		setCurrentEnemy(currentLevel);
	}
}

function setButton (level) {
	let weapon = levels[level].WEAPN;
	firebutton.src = `textures/${emojiList[weapon]}.png`;
}

function setCurrentEnemy(level) {
	let enemy = levels[level].ENEMY;
	
	markerRoot1.remove(currentEnemy);

	currentEnemy = emojiMeshes[enemy].clone();
		currentEnemy.geometry.translate(0,0.5,0);
	
	markerRoot1.add(currentEnemy);
}

function update()
{
	bullets.map(b=>b.update());
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
		arToolkitContext.update( arToolkitSource.domElement );
}

const bullets = [];
const GRAVITY = new THREE.Vector3(0,-0.01,0);
class Bullet {
	constructor(mesh, direction, life = 10, scene) {
		this.totalLife = life;
		this.life = life;
		this.dead = false;
		this.mesh = mesh.clone();
		this.velocity = direction;
		//this.velocity.normalize();
		this.rng = (0.5 - Math.random()) * 0.2;
		this.scene = scene;
		this.scene.add(this.mesh);
		bullets.push(this);
	}

	update() {
		if (this.life < 0 || this.mesh.position.z < 0) {
			this.dead = true;
			this.scene.remove(this.mesh);
		} else {
			this.velocity.add(GRAVITY);

			if(this.mesh.position.y < 0.5) {
				this.mesh.position.y = 0.5;
				this.velocity.y *= -0.5;
			}
			let prog = this.life / this.totalLife;
			this.mesh.scale.set(prog, prog, prog);
			this.mesh.position.add(this.velocity);
			this.mesh.rotateZ(this.rng);

			this.life--;
		}
	}
}

var lastShot = 0;
var shotRate = 0.2;
var worldDirection = new THREE.Vector3();
function shoot (parent, scene) {
	let now = performance.now();
	if (now - lastShot > shotRate * 1000) {
		lastShot = now;

		let mesh = emojiMeshes[levels[currentLevel].WEAPN].clone();
			mesh.position.copy(new THREE.Vector3(0,0,4));
		new Bullet(
			mesh,
			new THREE.Vector3(0,Math.random()*0.2,-0.2),
			25,
			scene
		);
	}
}


function render()
{

	boxes.map(c=>{
		c.position.y -= deltaTime;
	})

	if(touch) {
		shoot( camera, markerRoot1 );
	}

	renderer.render( scene, camera );

}




function animate()
{
	requestAnimationFrame(animate);
	deltaTime = clock.getDelta();
	totalTime += deltaTime;
	update();
	render();
}

</script>

</body>
</html>