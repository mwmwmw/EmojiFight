<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>EMOJI BATTLE</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<script src='js/GLTFLoader.js'></script>
	<!-- include jsartookit -->
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>
	<style>
	.objects {

		position: absolute;
		top: 0;
		left: 0;
	}
	</style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<script>

var scene, camera, renderer, clock, deltaTime, totalTime, raycastCamera;
var intersectables =[];
var arToolkitSource, arToolkitContext;

var markerRoot1;

var mesh1;

var box = new THREE.BoxGeometry(0.2, 0.2, 0.2);
var boxMat = new THREE.MeshBasicMaterial();
var boxMesh = new THREE.Mesh(box, boxMat);

var boxes = [];


//var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2(-10000,-10000);
var touch = false;
window.addEventListener("touchstart", (e)=>{
	mouse.x = e.touches[0].clientX / window.innerWidth;
	mouse.y = e.touches[0].clientY / window.innerHeight;
	touch = true;
})
window.addEventListener("touchend", (e)=>{
	touch = false;
	mouse.x = -10000;
	mouse.y = -10000;
})

let emojiMeshes = [];
let currentLevel = 0;
let levels = [
		{
			ENEMY: 3, // Lion
			WEAPN: 1,
		},{
			ENEMY: 4, // Lock
			WEAPN: 2,
		},{
			ENEMY: 1, // Fire
			WEAPN: 9,
		},{
			ENEMY: 7, // Toilet
			WEAPN: 5,
		},{
			ENEMY: 8, // Toilet
			WEAPN: 6,
		},
	]

function initialize()
{
	scene = new THREE.Scene();

	let ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 );
	scene.add( ambientLight );
				
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
	});

	function onResize()
	{
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		onResize()
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono'
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	markerRoot1 = new THREE.Group();
	scene.add(markerRoot1);
	let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
		type: 'pattern', patternUrl: "data/emojifight-bw.patt",
	})

	let loader = new THREE.TextureLoader();

	let emojiTextureExtension = "png";
	let emojiList = [
		"burger",
		"fire",
		"key",
		"lion",
		"lock",
		"poo",
		"soccer",
		"toilet",
		"trophy",
		"water",
	];


	
	let textures = {};

	emojiList.map(t=>{
		textures[t] = loader.load(`textures/${t}.${emojiTextureExtension}`);
	})

	let emojiGeometry = new THREE.PlaneBufferGeometry(1,1, 4,4);
		//emojiGeometry.translate(0,0.5,0);
	let emojiMaterial = new THREE.MeshBasicMaterial({
		side: THREE.DoubleSide,
	});
	let emojiMesh = new THREE.Mesh(emojiGeometry, emojiMaterial);
	
	

	Object.keys(textures).map((k,i)=>{
		const newEmoji = emojiMesh.clone();
			newEmoji.material = emojiMaterial.clone();
			newEmoji.material.map = textures[k];
			newEmoji.material.alphaTest = 0.5;
			newEmoji.material.needsUpdate = true;
			newEmoji.name = k;
			emojiMeshes.push(newEmoji);
	})

	function onProgress(xhr) { console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); }
	function onError(xhr) { console.log( 'An error happened' ); }
	
	let modelLoader = new THREE.GLTFLoader();

	markerRoot1.add(emojiMeshes[levels[currentLevel].ENEMY]);

// 	modelLoader.load( 'models/EmojiBattleGround.glb', function ( gltf ) {
// 		///intersectables = [...gltf.scene.children];	
// 		markerRoot1.add(...gltf.scene.children);
// 			//intersectables.map((c)=>console.log("type:",c.type));

// 			scene.add(boxMesh);
// 		});
}


function update()
{
	bullets.map(b=>b.update());
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
		arToolkitContext.update( arToolkitSource.domElement );
}

const bullets = [];

class Bullet {
	constructor(mesh, direction, life = 100, scene) {
		this.life = life;
		this.dead = false;
		this.mesh = mesh.clone();
		this.velocity = direction;
		this.velocity.normalize();
		this.rng = (0.5 - Math.random()) * 0.2;
		scene.add(this.mesh);
		bullets.push(this);
	}

	update() {
		if (this.life < 0) {
			this.dead = true;
			scene.remove(this.mesh);
		} else {
			this.mesh.position.add(this.velocity);
			this.mesh.rotateZ(this.rng);

			this.life--;
		}
	}
}

var lastShot = 0;
var shotRate = 0.2;
var worldDirection = new THREE.Vector3();
function shoot (parent, scene) {
	let now = performance.now();
		if (now - lastShot > shotRate * 1000) {
			lastShot = now;
			var dir = parent.getWorldDirection(worldDirection);
			dir.multiplyScalar(2);

			let mesh = emojiMeshes[levels[currentLevel].WEAPN].clone();
				mesh.position.copy(parent.position);
				mesh.rotation.copy(parent.rotation);
			new Bullet(
				mesh,
				dir.clone(),
				100,
				scene
			);
			//shot.play();
}
}


function render()
{

	boxes.map(c=>{
		c.position.y -= deltaTime;
	})

	if(touch) {
		shoot(camera, scene);
	}

	renderer.render( scene, camera );
}


function animate()
{
	requestAnimationFrame(animate);
	deltaTime = clock.getDelta();
	totalTime += deltaTime;
	update();
	render();
}

initialize();
animate();



</script>

</body>
</html>