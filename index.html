<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>EMOJI BATTLE</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<script src='js/GLTFLoader.js'></script>
	<!-- include jsartookit -->
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>

	<link href="https://fonts.googleapis.com/css?family=Barlow+Condensed|Bungee" rel="stylesheet">

	<style>

.loading {
	border:0.1em dashed white;
	width: 70px;
	height: 70px;
	border-radius: 100px;
	animation: load 5s linear infinite;
}

@keyframes load {
	0% {
		transform: rotateZ(0deg);
	}
	100% {
		transform:  rotateZ(360deg);
	}
}

@keyframes swizzle {
	0% {
		transform: scale(0.8) rotateZ(-3deg);
	}
	25% {
		transform: scale(1.5) rotateZ(5deg);
	}
	50% {
		transform: scale(0.8) rotateZ(3deg);
	}
	75% {
		transform: scale(1.5) rotateZ(-5deg);
	}
	100% {
		transform: scale(0.8) rotateZ(-3deg);
	}
}

	.fullscreen {
		position: absolute;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
	}

	.titlefont {
		font-family: 'Bungee', cursive;
		color: white;
		font-size: 6vh;
	}

	
	.setupQuestion {
		font-family: 'Bungee', cursive;
		color: white;
		font-size: 3vh;
	}

	.setupInstructions {
		font-family: 'Barlow Condensed', cursive;
			color: white;
			font-size: 3vh;
	}

	.centerItems {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		text-align: center;
	}

	#titlescreen {
		z-index: 100;
	}

	#titlescreen img {
		height: 50vh;
		width: 50vh;
		animation: swizzle 3s ease-in-out infinite;
	}

	#setupscreen {
		z-index: 1000;
	}

	#setupscreen img {
		height: 15vh;
		width: 15vh;
		align-self:center;
		justify-content: flex-start;
		position: absolute;
		top:0;
	}

	.rectangle {    
		background: radial-gradient(circle, #00CFFF 0%, #00FFDF 100%);
	}

	.show {
		opacity: 1;
		transition: opacity 1s;
	}
	.hide {
		opacity: 0;
		transition: opacity 1s;
		pointer-events: none;
	}

	.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
}

#UI{
	justify-content: flex-end;
}

.button img {
	position: relative;
	width: 100%;
	height: 100%;
}
.button {
	border-radius: 100%;
	height: 10vh;    
	width: 10vh;     
	border: 1px solid #F7DD00;    
	background-color: rgba(216,216,216,0.5);
	margin-bottom: 10vh;
}
.button:active {
	border: 1px solid #FF00B4;    
	background-color: rgba(216,216,216,0.5);
}

	</style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;' class="noselect">

<div id="StartScreenUI">
	<div id="setupscreen" class="show rectangle fullscreen centerItems">
		<img src="images/EmojiFightLogo.png" />
		<p class="setupInstructions">To experience in AR, <br/>
				Emoji Fight needs your camera</p>
		<div class="setupQuestion">Can We Use It?</div>
	</div>

	<div id="titlescreen" class="hide rectangle fullscreen titlefont centerItems">
			<img src="images/EmojiFightLogo.png" />
			<div id="loading" class="loading"></div>
			<div id="start" class="hide">START</div>
		</div>


</div>

<div id="UI" class="fullscreen centerItems">
	<a class="button"><img id="firebutton" src="textures/fire.png" /></a>
	</div>

<script src="js/game.js"></script>

<script>

/*
var scene, camera, renderer, clock, deltaTime, totalTime, raycastCamera;
var intersectables =[];
var arToolkitSource, arToolkitContext;

var markerRoot1 = new THREE.Group();

var mesh1;

var box = new THREE.BoxGeometry(0.2, 0.2, 0.2);
var boxMat = new THREE.MeshBasicMaterial();
var boxMesh = new THREE.Mesh(box, boxMat);

var boxes = [];
//var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2(-10000,-10000);
var touch = false;



// TITLE STUFF //

let firebutton = document.getElementById("FireButton");
let setupPage = document.getElementById("setupscreen");
let titlescreen = document.getElementById("titlescreen");

function setupPageInit () {
	initialize();
	setupPage.classList.remove('show');
	setupPage.classList.add("hide");
	titlescreen.classList.remove("hide");
	titlescreen.classList.add("show");
}

setupPage.addEventListener("touchstart", setupPageInit);
setupPage.addEventListener("click", setupPageInit);

function titlePageInit() {
	titlescreen.classList.remove('show');
	titlescreen.classList.add("hide");
	animate();
}

titlescreen.addEventListener("touchstart", titlePageInit);
titlescreen.addEventListener("click", titlePageInit);

window.addEventListener("touchstart", (e)=>{
	e.preventDefault();
	touch = true;
})
window.addEventListener("touchend", (e)=>{
	e.preventDefault();
	touch = false;
})

window.addEventListener("mousedown", (e)=>{
	e.preventDefault();
	touch = true;
})
window.addEventListener("mouseup", (e)=>{
	e.preventDefault();
	touch = false;
})

let emojiTextureExtension = "png";
	let emojiList = [
		"burger",
		"fire",
		"key",
		"lion",
		"lock",
		"poo",
		"soccer",
		"toilet",
		"trophy",
		"water",
	];

let emojiMeshes = [];
let currentLevel = 0;
let currentEnemy = null;
let levels = [
	{
		ENEMY: 3, // Lion
		WEAPN: 0,
		HEALTH: 30,
		SWEET_SPOT: 20,
		SWEET_SPOT_SIZE: 5,
	},{
		ENEMY: 4, // Lock
		WEAPN: 2,
		HEALTH: 10,
		SWEET_SPOT: 20,
		SWEET_SPOT_SIZE: 5,
	},{
		ENEMY: 1, // Fire
		WEAPN: 9,
		HEALTH: 10,
		SWEET_SPOT: 20,
		SWEET_SPOT_SIZE: 5,
	},{
		ENEMY: 7, // Toilet
		WEAPN: 5,
		HEALTH: 10,
		SWEET_SPOT: 20,
		SWEET_SPOT_SIZE: 5,
	},{
		ENEMY: 8, // Trophy
		WEAPN: 6,
		HEALTH: 10,
		SWEET_SPOT: 20,
		SWEET_SPOT_SIZE: 5,
	},
];

function generateGeometry(progress = 1, size = 0.5, startAngle = -90, resolution = 64) {
  const rads = THREE.Math.degToRad(startAngle);
  const circleSize = THREE.Math.degToRad(360);
  return new THREE.RingBufferGeometry( size, size-(size*0.25), resolution, 1, rads, (circleSize * progress) );
}

var progressRing = generateGeometry(0.5);
var material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
var circle = new THREE.Mesh( progressRing, material );
	circle.rotateX(THREE.Math.degToRad(90));

function initialize()
{
	scene = new THREE.Scene();

	let light = new THREE.HemisphereLight( 0xFFFFFF, 0x101010, 4. );

	light.position.y = 1;
	scene.add( light );
				
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		//sourceType : 'webcam',
		sourceType : 'video',
		sourceUrl : "./images/testvid.mp4",
	});

	function onResize()
	{
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		onResize()
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono'
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	
	let meshloader = new THREE.GLTFLoader().load('./models/lion.glb', (gltf)=>{

		gltf.scene.traverse((c)=>{
			if(c.material) {
			let material = new THREE.MeshPhongMaterial({color: c.material.color, side: THREE.DoubleSide});
			c.material = material;
			}
		})
		

		markerRoot1.add(gltf.scene);

	})

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	markerRoot1 = new THREE.Group();
	scene.add(markerRoot1);
	let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
		type: 'pattern', patternUrl: "data/emojifight-bw.patt",
	})

	loadEmojis();
	setLevel(0);
	markerRoot1.add( circle );

}

function loadEmojis () {
	let loader = new THREE.TextureLoader();
	let textures = {};

	emojiList.map(t=>{
		textures[t] = loader.load(`textures/${t}.${emojiTextureExtension}`);
	})

	let emojiGeometry = new THREE.PlaneBufferGeometry(1,1, 4,4);
	let emojiMaterial = new THREE.MeshBasicMaterial({
		side: THREE.DoubleSide,
	});
	let emojiMesh = new THREE.Mesh(emojiGeometry, emojiMaterial);

	Object.keys(textures).map((k,i)=>{
		const newEmoji = emojiMesh.clone();
			newEmoji.geometry = emojiMesh.geometry.clone();
			newEmoji.material = emojiMaterial.clone();
			newEmoji.material.map = textures[k];
			newEmoji.material.alphaTest = 0.5;
			newEmoji.material.needsUpdate = true;
			newEmoji.name = k;
			emojiMeshes.push(newEmoji);
	})
}

function setLevel(level) {

	if(levels[level]) {
		currentLevel = level;
		setButton(currentLevel);
		setCurrentEnemy(currentLevel);
	} else {
		setLevel(0);
	}

}

function setButton (level) {
	let weapon = levels[level].WEAPN;
	firebutton.src = `textures/${emojiList[weapon]}.png`;
}

function setCurrentEnemy(level) {
	let enemy = levels[level].ENEMY;
	
	markerRoot1.remove(currentEnemy);

	currentEnemy = emojiMeshes[enemy].clone();
		currentEnemy.geometry = currentEnemy.geometry.clone().translate(0,0.5,0);
	
	markerRoot1.add(currentEnemy);
}

var hits = 0;
var hitTarget = 0;
var gameTarget = 0;

function update()
{
	hitTarget += ((hits/levels[currentLevel].HEALTH) - hitTarget) * 0.2;
	if(hits < levels[currentLevel].HEALTH) {
		circle.geometry = generateGeometry(hitTarget);
	} else {
		hits = 0;
		hitTarget = 0;
		setLevel(currentLevel + 1);
		circle.geometry = generateGeometry(hitTarget);
	}
	

	bullets.map(b=>b.update());
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
		arToolkitContext.update( arToolkitSource.domElement );
}

const bullets = [];
const GRAVITY = new THREE.Vector3(0,-0.01,0);
class Bullet {
	constructor(mesh, direction, life = 10, scene) {
		this.totalLife = life;
		this.life = life;
		this.dead = false;
		this.mesh = mesh.clone();
		this.velocity = direction;
		//this.velocity.normalize();
		this.rng = (0.5 - Math.random()) * 0.2;
		this.scene = scene;
		this.scene.add(this.mesh);
		bullets.push(this);
	}

	update() {
		if(!this.dead) {
		if (this.life < 0 || this.mesh.position.z < 0) {
			this.dead = true;
			this.scene.remove(this.mesh);
			hits++;
		} else {
			this.velocity.add(GRAVITY);

			if(this.mesh.position.y < 0.5) {
				this.mesh.position.y = 0.5;
				this.velocity.y *= -0.5;
			}
			let prog = this.life / this.totalLife;
			this.mesh.scale.set(prog, prog, prog);
			this.mesh.position.add(this.velocity);
			this.mesh.rotateZ(this.rng);

			this.life--;
		}
	}
	}
}





var lastShot = 0;
var shotRate = 0.2;
var worldDirection = new THREE.Vector3();
function shoot (parent, scene) {
	let now = performance.now();
	if (now - lastShot > shotRate * 1000) {
		lastShot = now;

		let mesh = emojiMeshes[levels[currentLevel].WEAPN].clone();
			mesh.position.copy(new THREE.Vector3(0,0,4));
		new Bullet(
			mesh,
			new THREE.Vector3(0,Math.random()*0.2,-0.2),
			25,
			scene
		);
	}
}




function render()
{

	boxes.map(c=>{
		c.position.y -= deltaTime;
	})

	if(touch) {
		shoot( camera, markerRoot1 );
	}

	renderer.render( scene, camera );

}




function animate()
{
	requestAnimationFrame(animate);
	deltaTime = clock.getDelta();
	totalTime += deltaTime;
	update();
	render();
}

*/

</script>

</body>
</html>